------------------------------ MODULE Prophecy ------------------------------
(***************************************************************************)
(* We first introduce a definition that we need.                           *)
(***************************************************************************)
PartialInjections(U, V) == 
  (*************************************************************************)
  (* The set of injective (one-one) functions from a subset of U into V.   *)
  (*************************************************************************)
   LET PartialFcns == UNION { [D -> V] : D \in SUBSET U}
   IN {f \in PartialFcns : \A x, y \in DOMAIN f : (x # y) => (f[x] # f[y])}

CONSTANTS Pi, Dom, DomPrime 
   
(***************************************************************************)
(* We let Pi be an arbitrary set of individual prediction values.  A       *)
(* `prophecy' is an element of [D -> Pi] for some set D.  Our guiding      *)
(* example will be one in which a prophecy is a finite sequence of         *)
(* predictions--that is an element of Seq(Pi).                             *)
(*                                                                         *)
(* We let Spec equal Init /\ [][Next]_vars, where vars is the tuple of all *)
(* specification variables, and we describe how to add a prophecy variable *)
(* p to Spec to form a specification SpecP such that Spec is equivalent to *)
(* \EE p : SpecP.  We define InitP and NextP and let                       *)
(*                                                                         *)
(*   SpecP == InitP /\ [][NextP]_<<vars, p>>.                              *)
(*                                                                         *)
(* First we define a state function Dom whose value in any state will be   *)
(* the domain of the prophecy p.                                           *)
(*                                                                         *)
(*   InitP == Init /\ (p \in [Dom -> Pi])                                  *)
(*                                                                         *)
(* We define NextP by assuming a disjunctive representation of Next, and   *)
(* replacing each subaction A of that representation by the action         *)
(*                                                                         *)
(*    ProphAction(A) == A /\ Pred(p) /\ (p' \in NewPSet(p))                *)
(*                                                                         *)
(* where Pred and NewPSet are operators whose definitions may depend on    *)
(* the unprimed and primed variables of vars and the context variables of  *)
(* A in the disjunctive representation.  Think of Pred(p) as the prophecy  *)
(* that the value of p makes about the action A.  (Note: we write A /\     *)
(* Pred(p) instead of Pred(p) /\ A because TLC will not handle the latter  *)
(* if Pred(p) contains primed variables.) Let <<k; K>> be the context of A *)
(* in the disjunctive representation.                                      *)
(*                                                                         *)
(* Because I haven't figured out yet how to handle the possibility that A  *)
(* allows stuttering steps, I assume that it doesn't.  (Replacing A by A   *)
(* /\ (vars' # vars) produces an equivalent specification.) It's possible  *)
(* that prophecying that a stuttering step occurs might allow a prophecy   *)
(* variable to introduce stuttering.                                       *)
(*                                                                         *)
(* We require Pred to satisfy the following, where \A <<k; K>> : F means   *)
(*                                                                         *)
(*            \A k_1 \in K_1 :  ...  \A k_n \in K_n : F                    *)
(*                                                                         *)
(* and is simply F if k is the null context.                               *)
(*                                                                         *)
(*   Condition 1                                                           *)
(*      \A <<k; K>> : A => (\E q \in [Dom -> Pi] : Pred(q))                *)
(*                                                                         *)
(* To explain how Pred and NewPSet are defined, we suppose that we         *)
(* define two transition functions PredDom and DomInj.  (A transition      *)
(* function is an expression that may contain primed and unprimed          *)
(* variables.) These expressions may also depend on the context variables  *)
(* k of the subaction A.  Here is a description of these transition        *)
(* functions.                                                              *)
(*                                                                         *)
(*   PredDom: Always a subset of Dom.  It is the subset of Dom consisting  *)
(*            of the elements d for which Pred(p) may depend on            *)
(*            the value of p[d].  More precisely, Dom, PredDom, and        *)
(*            Pred satisfy                                                 *)
(*                                                                         *)
(*            Condition 2                                                  *)
(*                \A <<k; K>> :                                            *)
(*                   A => \A q, r \in [Dom -> Pi] :                        *)
(*                          (\A d \in PredDom : q[d] = r[d])               *)
(*                            => (Pred(q) = Pred(r))                       *)
(*                                                                         *)
(*   DomInj: An element of PartialInjections(Dom, Dom').  More precisely,  *)
(*           it must satisfy:                                              *)
(*                                                                         *)
(*           Condition 3                                                   *)
(*              \A <<k; K>> : A => DomInj \in PartialInjections(Dom, Dom') *)
(*                                                                         *)
(*           DomInj describes how the predictions of p are related to the  *)
(*           predictions in NewPSet(p).  In particular, it says that for   *)
(*           each d in DOMAIN DomInj, the prediction p[d] corresponds to   *)
(*           the prediction q[DomInj[d]] for any q in NewPSet[p].          *)
(*                                                                         *)
(*           In our example in which prophecies are elements of Seq(Pi),   *)
(*           suppose Dom = Dom' = 1..N and DomInj = [d \in 2..N |-> d-1].  *)
(*           Then the prophecies in NewPSet(p) consist of sequences        *)
(*           whose first N-1 predictions correspond to the predictions     *)
(*           of Tail(p), and whose Nth prediction is a new one.            *)
(*                                                                         *)
(*           We define NewPSet(p) to be the set of all prophecies          *)
(*           q in [Dom' -> Pi] such that                                   *)
(*                                                                         *)
(*               \A d \in (DOMAIN DomInj) \ PredDom : q[DomIn[d]] = p[d]   *)
(*                                                                         *)
(*           In other words, NewPSet(p) is the set of all prophecies q     *)
(*           obtained from p by choosing arbitrary new predictions in      *)
(*           Pi for each q[d] where d is either a newly created domain     *)
(*           element or corresponds under DomInj to an element of PredDom. *)
(*           Intuitively, this means that any prediction in p that is      *)
(*           used to determine AP must be replaced by an arbitrarily       *)
(*           chosen prediction in Pi, and any new prediction must          *)
(*           be of an arbitrary element in Pi.                             *)
(*                                                                         *)
(* Remember that there are different transition functions PredDom, and     *)
(* DomInj for each subaction A of Next, but there is just a single state   *)
(* function Dom.                                                           *)
(*                                                                         *)
(* It's obvious that SpecP implies Spec.  Here's an intuitive sketch of a  *)
(* proof of:                                                               *)
(*                                                                         *)
(*    THEOREM  ASSUME For every subaction A :                              *)
(*                     Spec => [][Conditions 1-3]_vars                     *)
(*             PROVE  Spec => \EE p : SpecP                                *)
(*                                                                         *)
(* To prove this, we let B be a behavior satisfying Spec and show that     *)
(* there's a behavior BP obtained by assigning values to p in each state   *)
(* so that BP satisfies SpecP.  For each step in B, choose a subaction of  *)
(* Next that the step satisfies.  For a stuttering step, we will just      *)
(* assume it comes from the [...]_vars part of the next-state action and   *)
(* not from any subaction of Next.  For such a step, we will always choose *)
(* the same values of p in both states.                                    *)
(*                                                                         *)
(* Using the sequence of values of Dom in each state and of DomInj for the *)
(* action chosen for each step, for any state s_i of B and any d in DOMAIN *)
(* p for the value of p in s_i, we can determine where the value of p[d]   *)
(* was chosen.  It was chosen either by the choice of p' in NewPSet(p)     *)
(* in executing an A step s_j -> s_(j+1) for some subaction A, or else in  *)
(* the initial predicate.  By conditions 1 and 2 (which by hypothesis hold *)
(* for every non-stuttering step) and the definition of NewPSet(p),        *)
(* there exist values of p[d] in Pi for all d in PredDom to make Pred(p)   *)
(* true in state s.  For all d, we then make that choice in the place      *)
(* where the current value of p[d] was chosen.  (This is possible because  *)
(* the value of p[d] is changed as soon as it's used.) This yields a set   *)
(* of possible behaviors BP in which InitP is true of the initial state    *)
(* and NextP is true for each non-stuttering step.  (There will be         *)
(* multiple choices of BP if not every prediction made in p is used.) QED  *)
(***************************************************************************)

ExistsGoodProphecy(Pred(_)) == \E q \in [Dom -> Pi] : Pred(q)
  (*************************************************************************)
  (* This asserts the conclusion of Condition 1.                           *)
  (*************************************************************************)   

IsDomInj(DomInj) == DomInj \in PartialInjections(Dom, DomPrime)
  (*************************************************************************)
  (* This becomes the conclusion of Condition 3 when Dom' is substituted   *)
  (* for DomPrime.  We define things this way because we want the current  *)
  (* module to be a constant module, so we can instantiate it easily when  *)
  (* defining SpecP.                                                       *)
  (*************************************************************************)

IsPredDom(PredDom, Pred(_)) ==
  (*************************************************************************)
  (* This asserts the conclusion of Condition 2.                           *)
  (*************************************************************************)
  /\ PredDom \subseteq Dom
  /\ \A q, r \in [Dom -> Pi] : 
          (\A d \in PredDom : q[d] = r[d]) => (Pred(q) = Pred(r))
 
NewPSet(p, DomInj, PredDom) ==
  (*************************************************************************)
  (* This is the set of all possible prophecy structures that can result   *)
  (* after an action is taken that satisfies the prediction made by the    *)
  (* prophecy structure p.  All elements of the resulting prophecy         *)
  (* structure that have either been used to make the prediction or that   *)
  (* do not correspond to elements of proph can assume any value in Pi.    *)
  (* Elements of the new prophecy structure that come from elements of     *)
  (* proph not involved in the prophecy retain their current value.        *)
  (*                                                                       *)
  (* Note that there is no useful generality in making new predictions for *)
  (* the elements that come from elements in proph that are not involved   *)
  (* in the prediction.  We can cause those elements in a set S to have    *)
  (* new predictions by redefining PredDom to equal PredDom \cup S .       *)
  (*************************************************************************)
  { q \in [DomPrime -> Pi] :
         \A d \in (DOMAIN DomInj) \ PredDom : q[DomInj[d]] = p[d]  }

ProphAction(A, p, pPrime, DomInj, PredDom,  Pred(_)) ==
  /\ A
  /\ Pred(p)
  /\ pPrime \in NewPSet(p,  DomInj, PredDom)   
  
ProphCondition(A, DomInj, PredDom,  Pred(_))  ==
  A => /\ ExistsGoodProphecy(Pred)
       /\ IsDomInj(DomInj)
       /\ IsPredDom(PredDom, Pred)
-----------------------------------------------------------------------------
(***************************************************************************)
(* We now make two definitions for convenience in using the operators      *)
(* defined here:                                                           *)
(*                                                                         *)
(*    EmptyFcn : The unique function whose domain is the empty set.        *)
(*                                                                         *)
(*    IdFcn(S) : The function in [S -> S] that maps every element of S to  *)
(*               itself.                                                   *)
(***************************************************************************)
EmptyFcn == << >>

IdFcn(S) == [i \in S |-> i]
=============================================================================
\* Modification History
\* Last modified Wed Oct 05 04:10:34 PDT 2016 by lamport
\* Created Fri Sep 16 06:52:33 PDT 2016 by lamport
